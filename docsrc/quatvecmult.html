<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <link rel="icon" href="img/eslogo196.png">
   <link rel="stylesheet" type="text/css" href="style.css">
   <link rel="stylesheet" href="highlight/matlab.css">
   <script src="highlight/highlight.min.js"></script>
   <script src="highlight/do_highlight.js"></script>
   <title>quatvecmult</title>
</head>

<body>

<header>
<ul>
<li><img src="img/eslogo42.png">
<li class="header-title">EasySpin
<li><a href="index.html">Documentation</a>
<li><a href="references.html">Publications</a>
<li><a href="http://easyspin.org" target="_blank">Website</a>
<li><a href="http://easyspin.org/academy" target="_blank">Academy</a>
<li><a href="http://easyspin.org/forum" target="_blank">Forum</a>
</ul>
</header>

<section>

<div class="functitle">quatvecmult</div>

<p>
Rotate 3-vectors using unit quaternions.
</p>

<!-- ============================================================= -->
<div class="subtitle">Syntax</div>

<pre class="matlab">
vecp = quatvecmult(q,vec)
</pre>

<!-- ============================================================= -->
<div class="subtitle">Description</div>

<p>
Rotates the 3-vector(s) <code>vec</code> using unit quaternion(s) <code>q</code>. The input 3-vector(s), which must be normalized to one, are given as a 3xN array. The unit quaternion(s), which must be normalized to one, are given as a 4xN array. The rotated vector(s) <code>vecp</code> are returned as a 3xN array.
</p>

<p>
Note that <code>quatvecmult</code> is vectorized and will accept arrays of unit quaternions of size 4xNxMx... and 3-vectors of size 3xNxMx... with an arbitrary number of dimensions, in which case the rotated vectors will be returned as an array of size 3xNxMx... .
</p>

<!-- ============================================================= -->
<div class="subtitle">Examples</div>

<p>
Taking an arbitrary 3-vector and quaternion and normalizing the results, we compute the rotated vector
</p>

<pre class="matlab">
q = [0.1; 0.438; -0.879; 0.699];
q = q./sqrt(sum(q.^2))
vec = [0.3; 0.9; -0.4];
vec = vec./sqrt(sum(vec.^2))
</pre>
<pre class="mloutput">
q =
    0.0827
    0.3621
   -0.7267
    0.5779
vec =
    0.2914
    0.8742
   -0.3885
</pre>
<pre class="matlab">
vecp = quatvecmult(q,vec)
</pre>
<pre class="mloutput">
vecp =
   -0.8705
    0.2851
   -0.4012
</pre>

<p>
We can convince ourselves that using <code>q</code> to rotate <code>vec</code> is just as valid as using the equivalent rotation matrix to rotate <code>vec</code>.
</p>

<pre class="matlab">
R = quat2rotmat(q);
R*vec
</pre>
<pre class="mloutput">
ans =
   -0.8705
    0.2851
   -0.4012
</pre>


<!-- ============================================================= -->
<div class="subtitle">See also</div>

<p>
<a class="esf" href="rotmat2quat.html">rotmat2quat</a>,
<a class="esf" href="quat2euler.html">quat2euler</a>,
<a class="esf" href="euler2quat.html">euler2quat</a>,
<a class="esf" href="quatinv.html">quatinv</a>
</p>

<hr>
</section>

<footer></footer>

</body>
</html>
